# Perpetuity [![Build Status](https://secure.travis-ci.org/jgaskins/perpetuity.png)](http://travis-ci.org/jgaskins/perpetuity)

Perpetuity is a simple Ruby object persistence layer that attempts to follow Martin Fowler's Data Mapper pattern, allowing you to use plain-old Ruby objects in your Ruby apps in order to decouple your domain logic from the database as well as speed up your tests. There is no need for your model classes to inherit from another class or even include a mix-in.

Your objects will hopefully eventually be able to be persisted into whichever database you like. Right now, only MongoDB is supported. Other persistence solutions will come later.

This gem was inspired by [a blog post by Steve Klabnik](http://blog.steveklabnik.com/posts/2011-12-30-active-record-considered-harmful).

## How it works

In the Data Mapper pattern, the objects you work with don't understand how to persist themselves. They interact with other objects just as in any other object-oriented application, leaving all persistence logic to mapper objects. This decouples them from the database and allows you to write your code without it in mind.

## Installation

Add the following to your Gemfile and run `bundle` to install it.

```ruby
gem 'perpetuity', github: 'jgaskins/perpetuity'
```

Once it's got enough functionality to release, you'll be able to remove the `github` parameter.

## Configuration

The only currently supported persistence method is MongoDB. Other schemaless solutions can probably be implemented easily.

```ruby
mongodb = Perpetuity::MongoDB.new host: 'mongodb.example.com', db: 'example_db'
Perpetuity.configure do 
  data_source mongodb
end
```

## Setting up object mappers

Object mappers are generated by the following:

```ruby
Perpetuity::Mapper.generate_for MyClass do
  # individual mapper configuration goes here
end
```

The primary mapper configuration will be configuring attributes to be persisted. This is done using the `attribute` method. Calling `attribute` will add the specified attribute and its class to the mapper's attribute set. This is how the mapper knows what to store and how to store it. Here is an example of an `Article` class, its mapper and how it can be saved to the database.

```ruby
class Article
  attr_accessor :title, :body
end

Perpetuity::Mapper.generate_for Article do
  attribute :title, String
  attribute :body, String
end

article = Article.new
article.title = 'New Article'
article.body = 'This is an article.'

Perpetuity::Mapper[Article].insert article
```

## Loading Objects

You can load all persisted objects of a particular class by sending `all` to the mapper object. Example:

```ruby
Perpetuity::Mapper[Article].all
```

You can load specific objects by calling the `find` method with an ID param on that class's mapper class and passing in the criteria. You may also specify more general criteria using the `select` method with a block similar to `Enumerable#select`.

```ruby
article  = Perpetuity::Mapper[Article].find params[:id]
users    = Perpetuity::Mapper[User].select { email == 'me@example.com' }
articles = Perpetuity::Mapper[Article].select { published_at < Time.now }
comments = Perpetuity::Mapper[Comment].select { article_id.in articles.map(&:id) }
```

Unfortunately, due to limitations in the Ruby language itself, this is as close as I could get to a true `Enumerable`-style select method. Once I can override `&&` and `||`, we can put more Rubyesque code in here.

These methods will return a Perpetuity::Retrieval object, which will lazily retrieve the objects from the database. They will wait to hit the DB when you begin iterating over the objects so you can continue chaining methods.

```ruby
article_mapper = Perpetuity::Mapper[Article]
articles = article_mapper.select { published_at < Time.now }
articles = articles.sort(:published_at).reverse
articles = articles.page(2).per_page(10) # built-in pagination

articles.each do |article| # This is when the DB gets hit
  # Display the pretty articles
end
```

## Associations with Other Objects

If an object references another object (such as an article referencing its author), it must have a relationship identifier in its mapper class. For example:

```ruby
class User
end

class Article
  attr_accessor :author

  def initialize(author)
    self.author = author
  end
end

Perpetuity::Mapper.generate_for User do
end

Perpetuity::Mapper.generate_for Article do
  attribute :author, User # Notice the author's class
end
```

This allows you to write the following:

```ruby
article_mapper = Perpetuity::Mapper[Article]
article = article_mapper.first
article_mapper.load_association! article, :author
user = article.author
```

## Customizing persistence

Setting the ID of a record to a custom value rather than using the DB default.

```ruby
Perpetuity::Mapper.generate_for Article do
  id { title.gsub(/\W+/, '-') } # use the article's parameterized title attribute as its ID
end
```

## Contributing

Right now, this code is pretty bare and there are possibly some design decisions that need some more refinement. You can help. If you have ideas to build on this, send some love in the form of pull requests or issues or tweets or e-mails and I'll do what I can for them.
